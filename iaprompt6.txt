Based on your query, you want to correctly load the text for buttons from a Markdown file (models.md) and display it in a Three.js scene. Below, I’ve provided the full code for the impacted files—index.html, buttons.js, and buttonsText.js—with the necessary changes applied to ensure the button texts are loaded and displayed correctly. These changes resolve the issue where the text wasn’t appearing due to a mismatch between the keys in the Markdown file and the JavaScript code.
Here’s the complete solution:
Impacted Files
index.html: Parses the Markdown file and passes the button text data to the JavaScript code.
buttons.js: Updates the button texts using the parsed data.
buttonsText.js: Creates the text meshes for the buttons (no changes needed here, but included for completeness).
Full Code for Impacted Files
1. index.html
This file fetches and parses the Markdown file (models.md), extracting the model data, including button texts, and passes it to the Three.js scene.
html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Model Viewer</title>
    <link rel="stylesheet" href="index.css">
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@v0.163.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@v0.163.0/examples/jsm/"
            }
        }
    </script>
    <style>
        .model-selector {
            position: fixed;
            width: 50%;
        }
        .model-selector select {
            width: 100%;
            padding: 5px;
        }
    </style>
</head>
<body>
    <div class="floating-text top-right">
        <p><a href="https://volkseco.ch" target="_blank">volks.eco</a></p>
    </div>
    
    <div class="floating-text top-center">
        <p>3D Model Description.</p>
    </div>

    <div class="model-selector">
        <label for="modelSelect">Select a 3D Model:</label>
        <select id="modelSelect" onchange="loadModel(this.value)">
            <option value="">--Choose a model--</option>
        </select>
    </div>

    <script type="module" src="./main.js"></script>
    <script>
        let models = [];

        async function loadModelsFromMarkdown() {
            try {
                const response = await fetch('3D_models/models.md');
                if (!response.ok) throw new Error('Failed to fetch models.md');
                const text = await response.text();
                const lines = text.split('\n');
                const models = [];
                let currentModel = null;

                lines.forEach(line => {
                    line = line.trim();
                    if (line.startsWith('# ')) {
                        if (currentModel) models.push(currentModel);
                        currentModel = { name: line.substring(2).trim(), description: '', links: {}, texts: {} };
                    } else if (line.startsWith('- ')) {
                        const match = line.match(/- (.+?):\s*(.+)/);
                        if (match) {
                            const key = match[1].trim();
                            const value = match[2].trim();
                            if (key === 'Model Description') {
                                currentModel.description = value;
                            } else if (key.startsWith('Model Link ')) {
                                const linkNum = key.substring(11).trim();
                                if (key.endsWith('text')) {
                                    currentModel.texts[`Bouton ${linkNum} text`] = value; // Store button text
                                } else {
                                    currentModel.links[`Bouton ${linkNum}`] = value; // Store button link
                                }
                            }
                        }
                    }
                });
                if (currentModel) models.push(currentModel);
                return models;
            } catch (error) {
                console.error('Error loading models:', error);
                return [];
            }
        }

        async function loadModelSelector() {
            models = await loadModelsFromMarkdown();
            const modelSelect = document.getElementById('modelSelect');
            models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.name;
                option.textContent = model.name;
                modelSelect.appendChild(option);
            });

            if (models.length > 0) {
                loadModel(models[0].name); // Load the first model by default
            } else {
                document.querySelector('.top-center p').textContent = 'No models available.';
            }
        }

        function loadModel(modelName) {
            const selectedModel = models.find(m => m.name === modelName);
            if (selectedModel) {
                document.querySelector('.top-center p').textContent = selectedModel.description;
                import('./main.js').then(main => {
                    main.loadSelectedModel(modelName);
                    main.setButtonLinks(selectedModel.links);
                    main.setButtonTexts(selectedModel.texts); // Pass button texts to the scene
                });
            }
        }

        window.onload = loadModelSelector;
    </script>
</body>
</html>
Key Changes:
The loadModelsFromMarkdown function now correctly parses button texts from the Markdown file using keys like Model Link 1 text and stores them as Bouton 1 text in the texts object.
The loadModel function passes the texts object to setButtonTexts in main.js, ensuring the button texts are available to the scene.
2. buttons.js
This file manages the creation and updating of buttons and their associated text meshes.
javascript
import * as THREE from 'three';
import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
import { createTextButtons } from './buttonsText.js';
import { config } from '../../config.js';

let currentButtonLinks = {};
let currentButtonTexts = {};
let buttons = [];
let textMeshes = [];

export function setButtonLinks(newLinks) {
    currentButtonLinks = newLinks;
}

export function setButtonTexts(newTexts) {
    console.log('Setting button texts:', newTexts);
    currentButtonTexts = newTexts;
    updateButtonTexts();
}

export function createButtons(scene, camera, renderer) {
    const buttonColors = config.buttons.colors;
    const numberOfButtons = config.buttons.number;
    const radius = (config.podium.size - config.buttons.size) * 0.85;
    const angleStep = (Math.PI * 2) / numberOfButtons;

    for (let i = 0; i < numberOfButtons; i++) {
        const name = `Bouton ${i + 1}`;
        const angle = i * angleStep;

        const buttonGeometry = new THREE.CylinderGeometry(config.buttons.size, config.buttons.size + 0.015, 0.04, 32);
        const buttonMaterial = new THREE.MeshStandardMaterial({ color: buttonColors[i] });
        const button = new THREE.Mesh(buttonGeometry, buttonMaterial);

        button.position.set(
            radius * Math.cos(angle),
            config.podium.height,
            radius * Math.sin(angle)
        );

        button.name = name;
        button.originalScale = button.scale.clone();
        button.originalColor = button.material.color.clone();

        button.lookAt(new THREE.Vector3(0, config.podium.height, 0));

        button.castShadow = true;
        button.receiveShadow = true;

        button.boundingBox = new THREE.Box3().setFromObject(button);

        scene.add(button);
        buttons.push(button);
    }

    createTextButtons(scene, numberOfButtons, radius, textMeshes);

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let hoveredButton = null;
    let clickedButton = null;

    function onMouseMove(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(buttons, false);

        let foundButton = null;
        intersects.forEach((intersect) => {
            const button = intersect.object;
            if (button.boundingBox.containsPoint(intersect.point)) {
                foundButton = button;
            }
        });

        if (foundButton && foundButton !== clickedButton) {
            if (hoveredButton !== foundButton) {
                if (hoveredButton) {
                    resetButton(hoveredButton);
                }
                highlightButton(foundButton);
                hoveredButton = foundButton;
            }
        } else if (!foundButton && hoveredButton) {
            resetButton(hoveredButton);
            hoveredButton = null;
        }
    }

    function highlightButton(button) {
        button.material.color.set(0xfff000);
        button.scale.set(1.05, 1.05, 1.05);
    }

    function resetButton(button) {
        if (button !== clickedButton) {
            button.material.color.copy(button.originalColor);
            button.scale.copy(button.originalScale);
        }
    }

    function onMouseClick(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(buttons, false);

        let clicked = null;
        intersects.forEach((intersect) => {
            const button = intersect.object;
            if (button.boundingBox.containsPoint(intersect.point)) {
                clicked = button;
            }
        });

        if (clicked && currentButtonLinks[clicked.name]) {
            if (clicked !== clickedButton) {
                if (clickedButton) {
                    resetButton(clickedButton);
                }
                clicked.material.color.set(0xffffff);
                clickedButton = clicked;
            }
            window.open(currentButtonLinks[clicked.name], '_blank');
        }
    }

    renderer.domElement.addEventListener('mousemove', onMouseMove);
    renderer.domElement.addEventListener('click', onMouseClick);
}

function updateButtonTexts() {
    const numberOfButtons = config.buttons.number;
    const angleStep = (Math.PI * 2) / numberOfButtons;
    const textRadius = (config.podium.size - config.buttons.size) * 0.85 + config.buttons.size * 2;

    textMeshes.forEach((textMesh, i) => {
        const angle = i * angleStep;
        const textX = textRadius * Math.cos(angle);
        const textZ = textRadius * Math.sin(angle);
        textMesh.position.set(textX, config.podium.height, textZ);
        textMesh.rotation.set(-Math.PI / 2, 0, Math.PI / 2 - angleStep * i);

        if (textMesh.geometry) textMesh.geometry.dispose();

        // Access the text using the correct key
        const newText = currentButtonTexts[`Bouton ${i + 1} text`] || '';
        textMesh.geometry = new TextGeometry(newText, {
            font: textMesh.userData.font,
            size: config.text.size,
            depth: 0.005,
            curveSegments: 6,
            bevelEnabled: false
        });

        textMesh.geometry.computeBoundingBox();
        const textWidth = textMesh.geometry.boundingBox.max.x - textMesh.geometry.boundingBox.min.x;
        textMesh.geometry.translate(-textWidth / 2, 0, 0);

        console.log(`Text mesh ${i} updated to "${newText}"`);
    });
}
Key Changes:
The updateButtonTexts function now uses the key Bouton ${i + 1} text to retrieve the text from currentButtonTexts, matching the structure of the data parsed from the Markdown file.
This ensures that the text meshes display the correct text (e.g., "Plans", "Guide", "BOM") instead of empty strings.
3. buttonsText.js
This file creates the text meshes and adds them to the scene. No changes are required, but it’s included for completeness.
javascript
import * as THREE from 'three';
import { FontLoader } from 'three/addons/loaders/FontLoader.js';
import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
import { config } from '../../config.js';

export function createTextButtons(scene, numberOfButtons, radius, textMeshes) {
    const loader = new FontLoader();
    loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {
        console.log('Font loaded successfully');
        const angleStep = (Math.PI * 2) / numberOfButtons;
        const textRadius = radius + config.buttons.size * 2;

        for (let i = 0; i < numberOfButtons; i++) {
            const angle = i * angleStep;

            const textGeometry = new TextGeometry("", {
                font: font,
                size: config.text.size,
                depth: 0.005,
                curveSegments: 6,
                bevelEnabled: false
            });

            const textMaterial = new THREE.MeshStandardMaterial({ color: config.text.color });
            const textMesh = new THREE.Mesh(textGeometry, textMaterial);

            textMesh.userData.font = font;

            const textX = textRadius * Math.cos(angle);
            const textZ = textRadius * Math.sin(angle);
            textMesh.position.set(textX, config.podium.height, textZ);
            textMesh.rotation.set(-Math.PI / 2, 0, Math.PI / 2 - angle);

            scene.add(textMesh);
            textMeshes.push(textMesh);
            console.log(`Text mesh ${i} created and added to scene at position (${textX}, ${config.podium.height}, ${textZ})`);
        }
    }, undefined, function (error) {
        console.error('Font loading failed:', error);
    });
}
Notes:
This file initializes the text meshes with empty strings and stores the loaded font in textMesh.userData.font for later use in buttons.js.
How It Works
Parsing the Markdown File (index.html):
The Markdown file (models.md) contains entries like - Model Link 1 text: Plans. These are parsed into a texts object with keys like Bouton 1 text.
The texts object is passed to setButtonTexts when a model is selected.
Updating the Button Texts (buttons.js):
The updateButtonTexts function retrieves the text for each button using the key Bouton ${i + 1} text and updates the corresponding text mesh.
The text meshes are positioned around the buttons and display the correct text.
Creating the Text Meshes (buttonsText.js):
The text meshes are created with an initial empty string and updated later when the text data is available.
Assumptions
The config.js file exists and provides settings like config.buttons.number, config.buttons.size, config.text.size, etc.
The main.js file imports setButtonLinks and setButtonTexts from buttons.js and calls them appropriately.
The Markdown file (models.md) follows a structure like:
# Model Name
- Model Description: Some description
- Model Link 1: https://example.com/plans
- Model Link 1 text: Plans
- Model Link 2: https://example.com/guide
- Model Link 2 text: Guide